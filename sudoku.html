<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JC'SUDOKU</title>
    <style>
    </style>
  </head>
  <body>
    <p>
        Go1! : find a cell with only one possible value <br>
        Go2! : find a row/col/square for which a missing number has only one possible position<br>
        SOLVE : Guess what !<br>
        <button id="go" onclick="solve()"> SOLVE </button> 
        <button id="go1" onclick="go1()"> Go1! </button> 
        <button id="go2" onclick="go2()"> Go2! </button>
    </p><br>
    <input type="text" maxlength="1" size="1" id="0">
    <input type="text" maxlength="1" size="1" id="1">
    <input type="text" maxlength="1" size="1" id="2">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="3">
    <input type="text" maxlength="1" size="1" id="4">
    <input type="text" maxlength="1" size="1" id="5">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="6">
    <input type="text" maxlength="1" size="1" id="7">
    <input type="text" maxlength="1" size="1" id="8">
    <br>
    <input type="text" maxlength="1" size="1" id="9">
    <input type="text" maxlength="1" size="1" id="10">
    <input type="text" maxlength="1" size="1" id="11">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="12">
    <input type="text" maxlength="1" size="1" id="13">
    <input type="text" maxlength="1" size="1" id="14">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="15">
    <input type="text" maxlength="1" size="1" id="16">
    <input type="text" maxlength="1" size="1" id="17">
    <br>
    <input type="text" maxlength="1" size="1" id="18">
    <input type="text" maxlength="1" size="1" id="19">
    <input type="text" maxlength="1" size="1" id="20">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="21">
    <input type="text" maxlength="1" size="1" id="22">
    <input type="text" maxlength="1" size="1" id="23">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="24">
    <input type="text" maxlength="1" size="1" id="25">
    <input type="text" maxlength="1" size="1" id="26">
    <br>
    <!-- deuxieme lignes de matriec 3x3 -->
    <br>     
    <input type="text" maxlength="1" size="1" id="27">
    <input type="text" maxlength="1" size="1" id="28">
    <input type="text" maxlength="1" size="1" id="29">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="30">
    <input type="text" maxlength="1" size="1" id="31">
    <input type="text" maxlength="1" size="1" id="32">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="33">
    <input type="text" maxlength="1" size="1" id="34">
    <input type="text" maxlength="1" size="1" id="35">
    <br>
    <input type="text" maxlength="1" size="1" id="36">
    <input type="text" maxlength="1" size="1" id="37">
    <input type="text" maxlength="1" size="1" id="38">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="39">
    <input type="text" maxlength="1" size="1" id="40">
    <input type="text" maxlength="1" size="1" id="41">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="42">
    <input type="text" maxlength="1" size="1" id="43">
    <input type="text" maxlength="1" size="1" id="44">
    &nbsp
    <br>
    <input type="text" maxlength="1" size="1" id="45">
    <input type="text" maxlength="1" size="1" id="46">
    <input type="text" maxlength="1" size="1" id="47">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="48">
    <input type="text" maxlength="1" size="1" id="49">
    <input type="text" maxlength="1" size="1" id="50">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="51">
    <input type="text" maxlength="1" size="1" id="52">
    <input type="text" maxlength="1" size="1" id="53">
    <br>
    <br>
    <input type="text" maxlength="1" size="1" id="54">
    <input type="text" maxlength="1" size="1" id="55">
    <input type="text" maxlength="1" size="1" id="56">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="57">
    <input type="text" maxlength="1" size="1" id="58">
    <input type="text" maxlength="1" size="1" id="59">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="60">
    <input type="text" maxlength="1" size="1" id="61">
    <input type="text" maxlength="1" size="1" id="62">
    <br>
    <input type="text" maxlength="1" size="1" id="63">
    <input type="text" maxlength="1" size="1" id="64">
    <input type="text" maxlength="1" size="1" id="65">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="66">
    <input type="text" maxlength="1" size="1" id="67">
    <input type="text" maxlength="1" size="1" id="68">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="69">
    <input type="text" maxlength="1" size="1" id="70">
    <input type="text" maxlength="1" size="1" id="71">
    <br>
    <input type="text" maxlength="1" size="1" id="72">
    <input type="text" maxlength="1" size="1" id="73">
    <input type="text" maxlength="1" size="1" id="74">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="75">
    <input type="text" maxlength="1" size="1" id="76">
    <input type="text" maxlength="1" size="1" id="77">
    &nbsp;
    <input type="text" maxlength="1" size="1" id="78">
    <input type="text" maxlength="1" size="1" id="79">
    <input type="text" maxlength="1" size="1" id="80">
    <br><br>
    <label >You can fill your own grid<br>or load the example number</label>
    <input type="number" min="0" max="1" value="" id="but">

    <script>
      if (typeof window !== 'undefined')
          console.log('Ce script est exécuté dans un navigateur.')
      else 
           console.log("Ce script N'est PAS exécuté dans un navigateur.")
      verbose = 0
      const LLL = []
      for (let i=0;i<81;i++) {
	    id = i.toString()
	    LLL.push(document.getElementById(id))
      }
      for (let i=0;i<81;i++) {
	    LLL[i].value=""//i.toString()
      }
      for (let i=0;i<81;i++) {
	    LLL[i].addEventListener('input',onEntryChange)
      }
      but = document.getElementById("but")
      but.addEventListener('input',onButtonChange)

      // cases des 9 lignes et 9 colonnes
      Ls=[[],[],[],[],[],[],[],[],[]]
      Cs=[[],[],[],[],[],[],[],[],[]]
      for (let l=0;l<9;l++) {
	    for (let c=0;c<9;c++) {
	        k = 9*l+c
	        Ls[l].push(k)
	        x = ~~(k/9)
	        y = k%9
	        Cs[l].push(x+y*9)
	    }
      }
      // cases des 9 squares
      Ss=[[],[],[],[],[],[],[],[],[]]
      for(let ix=0;ix<3;ix++) {
	    for(let iy=0;iy<3;iy++) {
	        k = ix*3+iy // index du square
	        // square (ix,iy)
	        x = ix*3 // coord du coin haut gauche
	        y = iy*3 // coord du coin haut gauche
	        for (let i=0;i<3;i++) {
		      for (let j=0;j<3;j++) {
		          a=x+i
		          b=y+j
		          Ss[k].push(a+b*9)
		      }
	        }
	    }
      }
      all = Ls.concat(Cs).concat(Ss) // conveniennce
      memberOfLCS = [] // memberOfLCS[k]=[l,c,s] means cell k belongs to Ls[l],Cs|c],Ss[s]
      for (let k=0;k<81;k++) {
	    for (let i=0;i<9;i++) {
	        if (Ls[i].includes(k))
		      l=i
	        if (Cs[i].includes(k))
		      c=i
	        if (Ss[i].includes(k))
		      s=i
	    }
	    memberOfLCS.push([l,c,s])
      }
      // buttons to show or hide
      let btGo1 = document.getElementById('go1')
      let btGo2 = document.getElementById('go2')

      // **********************************************************************
      //                            FUNCTIONS
      // **********************************************************************
      function f(k) {// to use without a browser in cli
      
      } // FIN function f(k) {// to use without a browser in cli

      function V(k){ // return the value in the cell k, ie 0 if invalide
	    c = LLL[k].value
	    val = Number(c)
	    if (isNaN(val))
	        return 0
	    if (val>=10)
	        return 0
	    return val
      } // FIN  function v(k){

      function valuesIn(param) { // param is a list of cells, return the list of the values of these cells
	    ans = []
	    for (let k=0;k<param.length;k++) {
	        x = V(param[k])
	        if (x!=0)
		      ans.push(x)
	    }
	    return ans
      } // FIN function valuesIn(cases)
      
      function possibilities(cell) { // return the list of the possible values for cell
	    let [l,c,s] = memberOfLCS[cell]
	    inLi = valuesIn(Ls[l])
	    inCo = valuesIn(Cs[c])
	    inSq = valuesIn(Ss[s])
	    let alreadyThere = inLi.concat(inCo).concat(inSq)
	    let possibilities = []
	    for (let i=1;i<=9;i++) 
	        if (!alreadyThere.includes(i))
		      possibilities.push(i)
	    return possibilities
      } // FIN function possibilities(cell)

      function canBePlaced(val,index) { // is it possible to place val in cell index
	    let [l,c,s] = memberOfLCS[index]
	    inLi = valuesIn(Ls[l])
	    inCo = valuesIn(Cs[c])
	    inSq = valuesIn(Ss[s])
	    let alreadyThere = inLi.concat(inCo).concat(inSq)
          return !alreadyThere.includes(val)
      } // FIN function canBePlaced(val,index)

      function nbEmptyCell() { // return the number of cell not affected
          let ans = 0
          for (let i=0;i<81;i++)
              ans += V(i)==0
          return ans
      } // FIN function nbEmptyCell()
      
      function checkValidity() { // check that there is no doublons on line,column or square and hide button is finish
	    // first test : coherence
	    // if not coherent alert and return
	    for (let k=0;k<all.length;k++) {
	        a = valuesIn(all[k])
	        b = new Set(a)
	        if (a.length != b.size) {
		      alert(`line/column/square ${k+1} has doublons`)
		      return 0
	        }
	    }
          let etat = (nbEmptyCell() == 0) ? 'hidden' : 'visible'
          btGo1.style.visibility = etat
          btGo2.style.visibility = etat
	    return 1
      } // FIN function checkValidity()

      function onButtonChange(event) { // This function is called each time the button changed
          let k = event.target.value
          if (k>=0 && k<=examples.length)
              example2LLL(examples[k])
      } // FIN function onButtonChange(event) 

      function onEntryChange(event) { // This function is called each time an entry has been changed
	    //console.log("Valeur actuelle : ", event.target.value);
          if (nbEmptyCell()!=81) { // restore the button go1 and go2 if needed
          }
	    let c = event.target.value
	    if (isNaN(Number(c))) {
	        event.target.value = ""
	    } else {
	        event.target.value = c=="0" ? "" : c
	    }
      } // FIN function onEntryChange(event) 
    
      function solve() {// testing all cells to find one with only one possible value
	    if (checkValidity()==0)
	        return
	    // testing all cells to find case with only one value
        dataIn=""
	    for (let k=0;k<81;k++) 
            dataIn+= (LLL[k].value == "") ? 0: LLL[k].value
        let grid = str2grid(dataIn)
        if (go(grid))
            for (let k=0;k<81;k++) {
                console.log(Math.floor(k/9),k%9)
                LLL[k].value = grid[Math.floor(k/9)][k%9]
            } 
       } // FIN function solve() 
            
        function go1() {// testing all cells to find one with only one possible value
	    if (checkValidity()==0)
	        return
	    // testing all cells to find case with only one value
	    for (let k=0;k<81;k++) {
	        if (LLL[k].value != "") // cell already affected
		      continue
	        let p = possibilities(k)
	        if (p.length==1) {
		      if (verbose>=1)
                      console.log("k= "+k+" on doit mettre "+p[0])
		      LLL[k].value = p[0].toString()
                  LLL[k].style.color = 'blue'
                  break
	        }
	    }
      } // FIN function go1() {

      function go2() { // find for any row, col, square if a missing number has only one place 
	    if (checkValidity()==0)
	        return
          // testing rows + column + square
          for (let l=0;l<all.length;l++) {
              let L = all[l]
              let vals = L.map(V)
              emptyPlaces = []
              alreadyThere = []
              missingValues = []
              for (i of L) {
                  if (V(i)==0) 
                      emptyPlaces.push(i)
                  else
                      alreadyThere.push(V(i))
              }
              //console.log("traite ligne "+l+"= "+L+"valeurs= "+vals+ " finalement "+alreadyThere+" libres "+emptyPlaces)
              for(let k=1;k<=9;k++) {
                  if (alreadyThere.includes(k))
                      continue
                  let Poss = []
                  for (i of emptyPlaces) {
                      //console.log("j'essaie "+k+ " en "+i)
                      if (canBePlaced(k,i))
                          Poss.push(i)
                  }
                  //console.log(k+" can go in "+Poss)
                  if (Poss.length==1) {
                      if (verbose)
                          console.log(k+" de la line/col/square "+l+" ne peut etre qu'en "+Poss[0])
                      LLL[Poss[0]].value = k
                      LLL[Poss[0]].style.color = 'red'
                      return
                  }
              }
          }          
          return
      } // FIN  function go2()
      
      function example2LLL(example) { // example est une chaine avec des blancs et de \n qui ne seront pas considere
	    if (example == undefined)
              return
          data = example.replace(/\s/g,'')
	    if (data.length!=81) {
	        alert("example2LLL : invalid argument")
	        return
	    }
	    for (let i=0;i<81;i++) {
	        c = data[i]
	        v = (isNaN(Number(c))) ? "" : c
	        if (v<=0 || v>=10)
		      v = ""
	        LLL[i].value = v
	    }
      } // FIN function example2LLL(example)

      example0=
    `000 000 000 000 000 000 000 000 000
    000 000 000 000 000 000 000 000 000
    000 000 000 000 000 000 000 000 000`
      
      example1= // facile
    `830 007 240
      640 020 509
      700 009 000  

      000 053 608
      900 201 007
      405 970 000

      000 700 005
      506 030 021
      098 100 034`
      example2= // diabolique ?
    `950 300 401
     000 500 002
     040 080 007

     009 000 050
     006 408 200
     070 000 300

     700 060 020
     800 007 000
     605 004 093`
      
      example3= // facile
    `300 024 007
     000 030 600
     970 651 002

     600 090 080
     250 000 079
     080 070 005

     500 743 018
     008 010 000
     700 560 004`

      example4= // difficile
     `508 004 000
      600 070 009
      000 030 060

      015 700 000
      920 080 041
      000 001 970

      060 010 000
      700 020 008
      000 900 302`

      example5= // demoniaque
    ` 900 417 005
      003 086 000
      000 900 040

      270 000 403
      430 000 098
      601 000 057

      050 001 000
      000 790 500
      700 528 006`
      examples = [example0,example1,example2,example3,example4,example5]
      //example2LLL(example4)
      but.value = ""
      but.max = examples.length-1

      function isValid(grid, row, col, num) {
    // Vérification de la ligne
    if (grid[row].includes(num)) {
        return false;
    }
    // Vérification de la colonne
    for (let i = 0; i < 9; i++) {
        if (grid[i][col] === num) {
            return false;
        }
    }
    // Vérification du carré 3x3
    let boxStartRow = Math.floor(row / 3) * 3;
    let boxStartCol = Math.floor(col / 3) * 3;
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            if (grid[boxStartRow + i][boxStartCol + j] === num) {
                return false;
            }
        }
    }
    return true;
}

let Perm = Array.from({ length: 81 }, (_, i) => i);

function myFindEmptyCell(grid) {
    for (let i = 0; i < 81; i++) {
        let x = Math.floor(Perm[i] / 9);
        let y = Perm[i] % 9;
        if (grid[x][y] === null) {
            return [x, y];
        }
    }
    return null;
}

function findEmptyCell(grid) {
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (grid[row][col] === null) {
                return [row, col];
            }
        }
    }
    return null;
}

function solveSudoku(grid) {
    let emptyCell = findEmptyCell(grid);
    if (!emptyCell) {
        return true;
    }
    let [row, col] = emptyCell;
    for (let num = 1; num <= 9; num++) {
        if (isValid(grid, row, col, num)) {
            grid[row][col] = num;
            if (solveSudoku(grid)) {
                return true;
            }
            grid[row][col] = null;
        }
    }
    return false;
}

function printSudoku(grid) {
    for (let i = 0; i < 9; i++) {
        console.log(grid[i].map(num => (num === null ? "." : num)).join(" "));
        if (i === 2 || i === 5) console.log(""); 
    }
}

function str2grid(str) {
    console.log(str)
    str = str.replace(/\s|\n/g, "");
    if (str.length !== 81) {
        return null;
    }
    let grid = Array.from({ length: 9 }, () => Array(9).fill(null));
    for (let i = 0; i < 81; i++) {
        let num = parseInt(str[i], 10);
        if (!isNaN(num) && num !== 0) {
            grid[Math.floor(i / 9)][i % 9] = num;
        }
    }
    return grid;
}

function go(sudokuGrid) {
    console.log("Grille Sudoku initiale :");
    printSudoku(sudokuGrid);
    if (solveSudoku(sudokuGrid)) {
        console.log("\nSolution trouvée :");
        printSudoku(sudokuGrid);
        return 1
    } else {
        console.log("\nPas de solution trouvée.");
        return 0
    }
}

    </script>
  </body>
</html>

